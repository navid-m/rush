<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>rush</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0a0a0a;
      color: #ffffff;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    #animation {
      border: 2px solid #333;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
      background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
      will-change: contents;
    }

    #controls {
      margin-top: 20px;
      padding: 15px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 5px;
    }

    button {
      background: #222;
      color: #0ff;
      border: 1px solid #0ff;
      padding: 8px 16px;
      margin: 0 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border-radius: 3px;
      transition: all 0.2s;
    }

    button:hover {
      background: #0ff;
      color: #000;
    }

    .key {
      display: inline-block;
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
      margin: 0 3px;
      font-weight: bold;
      color: #0ff;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #0ff;
    }

    #stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      max-width: 300px;
    }

    #current-commit {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      max-width: 400px;
    }
  </style>
</head>

<body>
  <div id="loading">Loading commit data...</div>

  <div id="stats"></div>
  <div id="current-commit"></div>

  <div id="container">
    <div id="animation"></div>
    <div id="controls">
      <button onclick="togglePause()">‚èØ Pause/Resume <span class="key">SPACE</span></button>
      <button onclick="changeSpeed(-0.5)">‚è™ Slower <span class="key">-</span></button>
      <button onclick="changeSpeed(0.5)">‚è© Faster <span class="key">+</span></button>
      <button onclick="restartAnimation()">üîÑ Restart <span class="key">R</span></button>
    </div>
  </div>

  <script>
    // Global variables for animation state
    let commits = [];
    let particles = [];
    let currentCommitIndex = 0;
    let frameCount = 0;
    let isPaused = false;
    let speed = 1;
    let animationFrameId = null;
    let lastFrameTime = 0;
    let authorColors = new Map();
    let gradientCache = new Set();
    let svg = null;
    let width = 1200;
    let height = 800;
    let hasCompleted = false;

    // Initialize the application
    async function init() {
      try {
        // Load commit data from JSON file
        const response = await fetch('commits-data.json');
        const data = await response.json();

        commits = data.commits;
        generateAuthorColors();

        // Setup SVG canvas
        setupSVG();

        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';

        // Show stats
        updateStats();

        // Start animation loop
        lastFrameTime = performance.now();
        animate(lastFrameTime);

        // Setup keyboard controls
        setupKeyboardControls();
      } catch (error) {
        console.error('Error loading commit data:', error);
        document.getElementById('loading').textContent = 'Error loading commit data: ' + error.message;
      }
    }

    function generateAuthorColors() {
      const authors = [...new Set(commits.map(c => c.author))];
      const colors = [
        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
        '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
      ];

      authors.forEach((author, i) => {
        authorColors.set(author, colors[i % colors.length]);
      });
    }

    function setupSVG() {
      const container = document.getElementById('animation');
      container.innerHTML = '';

      // Create SVG element
      svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('style', 'background: radial-gradient(circle at center, #0f0f1f 0%, #000000 100%)');

      // Add definitions for gradients
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      svg.appendChild(defs);

      // Add groups for particles and UI elements
      const particlesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      particlesGroup.setAttribute('class', 'particles');
      svg.appendChild(particlesGroup);

      container.appendChild(svg);
    }

    function setupKeyboardControls() {
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePause();
        } else if (e.code === 'Equal' || e.code === 'NumpadAdd') {
          changeSpeed(0.5);
        } else if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
          changeSpeed(-0.5);
        } else if (e.code === 'KeyR') {
          restartAnimation();
        }
      });
    }

    function togglePause() {
      isPaused = !isPaused;
      if (!isPaused && !hasCompleted) {
        lastFrameTime = performance.now();
        animate(lastFrameTime);
      }
      updateStats();
    }

    function changeSpeed(delta) {
      speed = Math.max(0.1, Math.min(10, speed + delta));
      updateStats();
    }

    function restartAnimation() {
      particles = [];
      currentCommitIndex = 0;
      frameCount = 0;
      hasCompleted = false;
      isPaused = false;
      lastFrameTime = performance.now();
      animate(lastFrameTime);
      updateStats();
    }

    function createParticlesForCommit(commit) {
      const fileColors = generateFileColors(commit.files);
      const authorColor = authorColors.get(commit.author) || '#ffffff';

      commit.files.forEach((filename, i) => {
        const angle = (i / commit.files.length) * Math.PI * 2;
        const elevation = (Math.random() - 0.5) * Math.PI * 0.5;
        const particleSpeed = 1.5 + Math.random() * 1.5;

        const particle = {
          id: `${commit.hash}-${filename}`,
          x: 0,
          y: 0,
          z: 0,
          vx: Math.cos(angle) * Math.cos(elevation) * particleSpeed,
          vy: Math.sin(elevation) * particleSpeed,
          vz: Math.sin(angle) * Math.cos(elevation) * particleSpeed,
          color: createGradientColor(fileColors[i], authorColor),
          size: 6 + Math.random() * 5,
          age: 0,
          maxAge: 120 + Math.random() * 80,
          filename: filename.split('/').pop() || filename,
          author: commit.author,
          commitHash: commit.hash,
          fileColor: fileColors[i],
        };

        particles.push(particle);
      });
    }

    function generateFileColors(filenames) {
      const colors = [];
      const modernColorPalette = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
        '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
        '#A3E4D7', '#FAD7A0', '#D5A6BD', '#AED6F1', '#A9DFBF'
      ];

      filenames.forEach((filename, index) => {
        const ext = filename.split('.').pop()?.toLowerCase() || '';
        let hash = 0;
        for (let i = 0; i < filename.length; i++) {
          hash = filename.charCodeAt(i) + ((hash << 5) - hash);
        }
        const colorIndex = Math.abs(hash) % modernColorPalette.length;
        colors.push(modernColorPalette[colorIndex]);
      });

      return colors;
    }

    function createGradientColor(fileColor, authorColor) {
      const gradientId = `gradient-${fileColor.replace('#', '').replace(/\./g, '')}-${authorColor.replace('#', '').replace(/\./g, '')}`;

      // Check cache to avoid recreating gradients
      if (gradientCache.has(gradientId)) {
        return `url(#${gradientId})`;
      }

      const defs = svg.querySelector('defs');
      const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
      gradient.setAttribute('id', gradientId);
      gradient.setAttribute('cx', '30%');
      gradient.setAttribute('cy', '30%');
      gradient.setAttribute('r', '70%');

      const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
      stop1.setAttribute('offset', '0%');
      stop1.setAttribute('stop-color', fileColor);
      stop1.setAttribute('stop-opacity', '0.95');

      const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
      stop2.setAttribute('offset', '100%');
      stop2.setAttribute('stop-color', authorColor);
      stop2.setAttribute('stop-opacity', '0.85');

      gradient.appendChild(stop1);
      gradient.appendChild(stop2);
      defs.appendChild(gradient);

      gradientCache.add(gradientId);
      return `url(#${gradientId})`;
    }

    function updateParticles() {
      // Batch particle updates for better performance
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        p.x += p.vx;
        p.y += p.vy;
        p.z += p.vz;
        p.age++;

        p.vy += 0.02;
        p.vx *= 0.99;
        p.vy *= 0.99;
        p.vz *= 0.99;

        // Remove dead particles inline
        if (p.age >= p.maxAge) {
          particles.splice(i, 1);
        }
      }
    }

    function project3D(x, y, z) {
      const perspective = 600;
      const scale = perspective / (perspective + z);

      return {
        x: width / 2 + x * scale,
        y: height / 2 + y * scale,
        scale,
      };
    }

    function render() {
      if (!svg) return;

      const particlesGroup = svg.querySelector('.particles');
      if (!particlesGroup) return;

      // Clear previous particles
      while (particlesGroup.firstChild) {
        particlesGroup.removeChild(particlesGroup.firstChild);
      }

      // Pre-compute all projections and visibility in one pass
      const projectedParticles = [];

      for (const p of particles) {
        const proj = project3D(p.x, p.y, p.z);

        // Early culling - skip particles outside view
        if (
          proj.x < -100 ||
          proj.x > width + 100 ||
          proj.y < -100 ||
          proj.y > height + 100
        ) {
          continue;
        }

        const ageFactor = 1 - p.age / p.maxAge;
        const opacity = ageFactor * 0.9;

        if (opacity <= 0.1) continue;

        projectedParticles.push({
          ...p,
          projX: proj.x,
          projY: proj.y,
          projScale: proj.scale,
          opacity,
        });
      }

      // Sort by z-depth for proper layering
      projectedParticles.sort((a, b) => b.z - a.z);

      // Draw circles for particles
      for (const p of projectedParticles) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', p.projX);
        circle.setAttribute('cy', p.projY);
        circle.setAttribute('r', p.size * p.projScale);
        circle.setAttribute('fill', p.color);
        circle.setAttribute('opacity', p.opacity);
        particlesGroup.appendChild(circle);
      }

      // Limit labels to young, close particles for performance
      const labelsToShow = projectedParticles.filter(
        (d) => d.age < 60 && d.projScale > 0.8,
      );

      for (const p of labelsToShow) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', p.projX + (p.size + 2) * p.projScale);
        text.setAttribute('y', p.projY - (p.size + 2) * p.projScale);
        text.setAttribute('fill', p.fileColor);
        text.setAttribute('opacity', p.opacity * 0.8);
        text.setAttribute('font-size', Math.max(8, 10 * p.projScale) + 'px');
        text.setAttribute('font-family', 'monospace');
        text.textContent = p.filename;
        particlesGroup.appendChild(text);
      }

      // Draw author legend
      drawAuthorLegend();
    }

    function drawAuthorLegend() {
      if (!svg) return;

      // Find or create legend group
      let legendGroup = svg.querySelector('.legend');
      if (!legendGroup) {
        legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        legendGroup.setAttribute('class', 'legend');
        svg.appendChild(legendGroup);
      } else {
        // Clear existing legend
        while (legendGroup.firstChild) {
          legendGroup.removeChild(legendGroup.firstChild);
        }
      }

      // Cache active authors to avoid repeated filtering
      const activeAuthors = new Set();
      for (const p of particles) {
        if (p.age < 60) {
          activeAuthors.add(p.author);
        }
      }

      const authors = Array.from(activeAuthors);
      const legendX = width - 200;
      let legendY = 50;

      // Legend title
      const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      title.setAttribute('x', legendX);
      title.setAttribute('y', legendY);
      title.setAttribute('fill', '#ffffff');
      title.setAttribute('font-family', 'monospace');
      title.setAttribute('font-size', '12px');
      title.setAttribute('font-weight', 'bold');
      title.textContent = 'Active Authors:';
      legendGroup.appendChild(title);

      legendY += 20;

      // Author entries
      authors.slice(0, 10).forEach((author) => {
        const color = authorColors.get(author) || '#ffffff';

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', legendX);
        circle.setAttribute('cy', legendY);
        circle.setAttribute('r', 4);
        circle.setAttribute('fill', color);
        legendGroup.appendChild(circle);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', legendX + 10);
        text.setAttribute('y', legendY + 4);
        text.setAttribute('fill', color);
        text.setAttribute('font-family', 'monospace');
        text.setAttribute('font-size', '11px');
        text.textContent = author.length > 20 ? author.substring(0, 20) + '...' : author;
        legendGroup.appendChild(text);

        legendY += 18;
      });
    }

    function updateStats() {
      const statsDiv = document.getElementById('stats');
      if (!statsDiv) return;

      let infoText = `Commits: ${currentCommitIndex}/${commits.length}<br>`;
      infoText += `Files: ${particles.length}<br>`;
      infoText += `Speed: ${speed.toFixed(1)}x<br>`;

      if (isPaused) {
        infoText += 'Status: PAUSED';
      } else if (hasCompleted) {
        infoText += 'Status: COMPLETED';
      } else {
        infoText += 'Status: RUNNING';
      }

      statsDiv.innerHTML = infoText;

      // Update current commit info
      const commitInfoDiv = document.getElementById('current-commit');
      if (commitInfoDiv && commits[currentCommitIndex - 1]) {
        const commit = commits[currentCommitIndex - 1];
        const date = new Date(commit.date).toLocaleDateString();
        const time = new Date(commit.date).toLocaleTimeString();
        commitInfoDiv.innerHTML = `
          <strong>${date} ${time}</strong><br>
          <em>${commit.author}</em>: ${commit.message.substring(0, 50)}
          ${commit.message.length > 50 ? '...' : ''}
        `;
      }
    }

    function animate(currentTime) {
      if (hasCompleted) {
        return;
      }

      if (isPaused) {
        animationFrameId = requestAnimationFrame(animate);
        return;
      }

      const deltaTime = currentTime - lastFrameTime;
      const frameInterval = 1000 / (75 * speed); // Target 75 FPS scaled by speed

      if (deltaTime >= frameInterval) {
        frameCount++;

        // Add new particles for commits based on speed
        const commitInterval = Math.floor(30 / speed);
        if (
          frameCount % commitInterval === 0 &&
          currentCommitIndex < commits.length
        ) {
          createParticlesForCommit(commits[currentCommitIndex]);
          currentCommitIndex++;
        }

        updateParticles();
        render();
        updateStats();

        // Check if animation is complete
        if (currentCommitIndex >= commits.length && particles.length === 0) {
          hasCompleted = true;
          updateStats();
        }

        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }

      animationFrameId = requestAnimationFrame(animate);
    }

    // Start the application when the page loads
    window.addEventListener('load', init);
  </script>
</body>

</html>